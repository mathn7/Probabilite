<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sujet TP3 · Probabilite.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.jpg" alt="Probabilite.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Probabilite.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Accueil</a></li><li><a class="tocitem" href="../Sujet_TP1/">Sujet TP1</a></li><li><a class="tocitem" href="../Sujet_TP2/">Sujet TP2</a></li><li class="is-active"><a class="tocitem" href>Sujet TP3</a><ul class="internal"><li><a class="tocitem" href="#Introduction-1"><span>Introduction</span></a></li><li><a class="tocitem" href="#Exercice-1-:-détection-de-pixels-voisins-ayant-des-gradients-parallèles-1"><span>Exercice 1 : détection de pixels voisins ayant des gradients parallèles</span></a></li><li><a class="tocitem" href="#Exercice-2-:-détection-des-alignements-dans-une-image-1"><span>Exercice 2 : détection des alignements dans une image</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Sujet TP3</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sujet TP3</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mathn7/Probabilite/blob/master/docs/src/Sujet_TP3.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="TP3-–-Perception-des-formes-dans-une-image-1"><a class="docs-heading-anchor" href="#TP3-–-Perception-des-formes-dans-une-image-1">TP3 – Perception des formes dans une image</a><a class="docs-heading-anchor-permalink" href="#TP3-–-Perception-des-formes-dans-une-image-1" title="Permalink"></a></h1><h2 id="Introduction-1"><a class="docs-heading-anchor" href="#Introduction-1">Introduction</a><a class="docs-heading-anchor-permalink" href="#Introduction-1" title="Permalink"></a></h2><p>Dans une image binaire de synthèse, on considère les pixels comme des variables aléatoires iid. Un pixel reçoit la valeur <span>$0(\text { pixel noir })$</span> avec la probabilité <span>$p$</span> ou la valeur 1 (pixel blanc) avec la probabilité <span>$1-p($</span>loi de Bernouilli de parametre <span>$p$</span> ). Malgré l&#39;indépendance entre pixels, des agglomérats de pixels noirs, en forme de carrés, peuvent apparaítre par le fait du hasard. La probabilité <span>$\mathcal{P}(p, t)$</span> pour qu&#39;un carré de côté <span>$t$</span> soit noir est égale à <span>$p^{t^{2}}$</span>. Elle diminue très rapidement si les carrés deviennent plus grands, c&#39;est-à-dire lorsque <span>$t$</span> croít, ou sì les pixels noirs se raréfient, c&#39;est-à-dire lorsque <span>$p$</span> décroít. Or, un carré noir se distingue d&#39;autant mieux qu&#39;il est plus grand ou que l&#39;image est plus claire (cf. figure 1). Cet exemple très simple illustre le principe général de la perception des formes dans une image : une forme est d&#39;autant plus perceptible qu&#39;elle est moins probable.</p><p><img src="../assets/image1_tp3.png" alt/> FIGURE 1- Chacune de ces images binaires de taille <span>$64 \times 64,$</span> tirées selon une loi de Bernouilli de paramètre <span>$p$</span> contient un carré noir unique de côté <span>$t=5 .$</span> La probabilité d&#39;apparition <span>$\mathcal{P}(p, t)=p^{t^{2}}$</span> du carré décroít de gauche à droite, ce qui le rend de plus en plus perceptible : notre ceil est attiré par les événements les moins probables!</p><p>Lancez le script <em>carres_noirs</em>, qui simule une séquence d&#39;images binaires aléatoires de taille <span>$64 \times 64$</span> tirées selon une loi de Bernouilli de paramètre <span>$p,$</span> jusqu&#39;à ce qu&#39;une de ces images contienne au moins un carré noir de côté <span>$t .$</span> Ce script teste plusieurs valeurs de <span>$t,$</span> pour <span>$p=0,5$</span> fixé. Attention : la recherche est de plus en plus longue, puisque la probabilité d&#39;apparition <span>$\mathcal{P}(p, t)=p^{t^{2}}$</span> d&#39;un carré noir décroít fortement lorsque <span>$t$</span> croít. Néanmoins, plus l&#39;attente est longue, plus la forme <em>&quot;saute aux yeux&quot;</em> dans l&#39;image affichée.</p><p>Comme cela a déjà été vu dans le TP1, les variables aléatoires que constituent les pixels d&#39;une image naturelle ne sont pas iid, mais sont au contraire fortement corrélées. C&#39;est la raison pour laquelle les formes perceptibles sont beaucoup plus courantes dans une image naturelle que dans une image aléatoire. En revanche, il s&#39;agit en général de formes approchées. Il est donc nécessaire de donner une définition plus souple à la notion de forme. Dans une image binaire aléatoire de taille <span>$T \times T$</span> tirée selon une loi de Bernouilli de paramètre <span>$p$</span>, la probabilité pour qu&#39;un carré de côté <span>$t,$</span> c&#39;est-à-dire constitué de <span>$N=t^{2}$</span> pixels, contienne exactement <span>$n \leqslant N$</span> pixels noirs, est donnée par la loi binomiale <span>$\mathcal{B}(p, N, n)=\mathrm{C}_{N}^{n} p^{n}(1-p)^{N-n},$</span> où <span>$\mathrm{C}_{N}^{n}$</span> désigne le nombre de combinaisons de <span>$n$</span> éléments parmi <span>$N$</span>. Par conséquent, la probabilité pour qu&#39;un tel carré contienne au moins <span>$n$</span> pixels noirs s&#39;écrit :</p><p><span>$\hspace*{2.5cm}$</span> <span>$\sum_{k=n}^{N} \mathcal{B}(p, N, k)=\sum_{k=n}^{N} \mathrm{C}_{N}^{k} p^{k}(1-p)^{N-k}=1-\sum_{k=0}^{n-1} \mathrm{C}_{N}^{k} p^{k}(1-p)^{N-k}$</span> <span>$(1)$</span> La dernière somme de (1) peut se calculer à l’aide de la fonction binocdf de Matlab (doc binocdf)</p><h2 id="Exercice-1-:-détection-de-pixels-voisins-ayant-des-gradients-parallèles-1"><a class="docs-heading-anchor" href="#Exercice-1-:-détection-de-pixels-voisins-ayant-des-gradients-parallèles-1">Exercice 1 : détection de pixels voisins ayant des gradients parallèles</a><a class="docs-heading-anchor-permalink" href="#Exercice-1-:-détection-de-pixels-voisins-ayant-des-gradients-parallèles-1" title="Permalink"></a></h2><p>Détecter les <em>&quot;alignements&quot;</em> dans une image consiste à faire une esquisse constituée de segments de droites. De tels segments se situent là où le module <span>$\|\nabla I\|$</span> du gradient du niveau de gris <span>$I$</span> est élevé. Pour détecter les alignements, il faut donc commencer par calculer le gradient du niveau de gris <span>$\nabla I$</span>, par exemple avec la fonction gradient (axe des abscisses orienté vers la droite, axe des ordonnées vers le bas, unité de longueur <span>$=$</span> pixel ). Une fois ce gradient calculé, seuls les pixels où sa norme est supérieure à un seuil sont sélectionnés. Parmi ces pixels, on cherche à constituer des ensembles <span>$E$</span> (cf. figure 2-gauche) tels que :</p><ul><li>chaque ensemble <span>$E$</span> soit connexe, au sens des <em>&quot;8 plus proches voisins&quot;</em></li><li>le gradient <span>$G_{i, j}=\nabla I(i, j)$</span> en un pixel <span>$(i, j)$</span> de <span>$E$</span> soit parallèle à la somme <span>$G_{\Sigma}$</span> des gradients calculée sur les pixels de l&#39;ensemble <span>$E$</span> en cours de construction, c&#39;est-à-dire <span>$\frac{G_{i, j}}{\left\|G_{i, j}\right\|} \cdot \frac{G_{\Sigma}}{\left\|G_{\Sigma}\right\|} \geqslant \cos \alpha,$</span> où <span>$\alpha&gt;0$</span> désigne l&#39;angle maximal autorisé entre les vecteurs <span>$G_{i, j}$</span> et <span>$G_{\Sigma}$</span> Après avoir lu attentivement le script exercice_1, complétez la fonction recursion, qui permet de construire, par appels récursifs, les ensembles <span>$E$</span> à partir de k &quot;germes&quot;. Les figures 2 -centre et 2 -droite montrent le résultat de l&#39;exécution de ce script sur l&#39;image <em>Piree.png</em> (les ensembles <span>$E$</span> sont affichés sous différentes couleurs).</li></ul><p><strong>Remarque</strong> – Les fonctions ind2sub et sub2ind de Matlab sont très utiles : consultez leur documentation.</p><p><img src="../assets/image2_tp3.png" alt/> Figure 2 – À gauche : exemple comportant trois ensembles candidats <span>$E$</span>. Au centre : image sur laquelle le gradient du niveau de gris est superposé aux pixels de contour. À droite : ensembles candidats <span>$E$</span> associés.</p><h2 id="Exercice-2-:-détection-des-alignements-dans-une-image-1"><a class="docs-heading-anchor" href="#Exercice-2-:-détection-des-alignements-dans-une-image-1">Exercice 2 : détection des alignements dans une image</a><a class="docs-heading-anchor-permalink" href="#Exercice-2-:-détection-des-alignements-dans-une-image-1" title="Permalink"></a></h2><p>Si la variable aléatoire <em>&quot;gradient du niveau de gris&quot;</em> en un pixel suivait une loi uniforme, la probabilité <span>$p$</span> pour qu&#39;une réalisation fasse un angle inférieur à <span>$\alpha$</span>, relativement à une direction de réference, vaudrait <span>$p=\frac{2 a}{2 \pi}=\frac{a}{\pi}$</span> Soit <span>$E$</span> un des ensembles de pixels constitués à l&#39;étape précédente. On définit <span>$R$</span> comme le plus petit rectangle englobant de <span>$E,$</span> de cótés parallèles aux axes principaux de sa matrice d&#39;inertie. Cette matrice est une généralisation de la matrice de variance/covariance, pour laquelle les coordonnées <span>$\left(x_{i}, y_{i}\right)$</span> sont pondérées par <span>$\pi_{i}=\|\nabla I\|_{i}$</span></p><p><span>$\hspace*{2.5cm}$</span> <span>$\bar{x}=\frac{1}{\Pi} \sum_{i=1}^{n} \pi_{i} x_{i} ;\\ \hspace*{2.5cm} \bar{y}=\frac{1}{\Pi} \sum_{i=1}^{n} \pi_{i} y_{i} ;\\ \hspace*{2.5cm} M_{1,1}=\frac{1}{\Pi} \sum_{i=1}^{n} \pi_{i}\left(x_{i}-\bar{x}\right)^{2} ;\\ \hspace*{2.5cm} M_{1,2}=\frac{1}{\Pi} \sum_{i=1}^{n} \pi_{i}\left(x_{i}-\bar{x}\right)\left(y_{i}-\bar{y}\right) ; \text { etc. }$</span></p><p>où <span>$\Pi=\sum_{i=1}^{n} \pi_{i} .$</span> Écrivez la fonction matrice<em>inertie, qui doit retourner les coordonnées <span>$(\bar{x}, \bar{y})$</span> du centre d&#39;inertie de <span>$E$</span> et sa matrice d&#39;inertie <span>$M,$</span> puis lancez le script test</em>matrice_inertie en guise de vérification. Une fois le rectangle <span>$R$</span> déterminé, on compte le nombre <span>$n$</span> de pixels <span>$(i, j)$</span> de <span>$E$</span> où <span>$\nabla I(i, j)$</span> fait un angle inférieur à <span>$\alpha$</span> avec la direction du petit axe de <span>$R$</span>. La probabilité pour que cela se produise en <span>$n$</span> pixels de <span>$R$</span> au moins est donnée par <span>$(1),$</span> où <span>$p=\frac{\alpha}{\pi}$</span> et <span>$N=\operatorname{card}(R) .$</span> Le critère pour déterminer si un ensemble candidat <span>$E$</span> forme un alignement détectable s&#39;écrit donc <span>$(\epsilon \ll 1$</span> est un seuil)</p><p><span>$\hspace*{2.5cm}$</span> <span>$1-\sum_{k=0}^{n-1} \mathrm{C}_{N}^{k} p^{k}(1-p)^{N-k}&lt;\epsilon$</span></p><p>Écrivez la fonction calcul_proba, qui doit calculer le premier membre de (3) (le nombre de pixels <span>$N$</span> doit être entier!). Une fois mis au point sur l&#39;image Piree.png, vous pourrez tester ces deux scripts sur les images chaises.png et Morlaix.png (le calcul est un peu long), ou sur toute autre image de votre choix.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Sujet_TP2/">« Sujet TP2</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 8 July 2020 10:20">Wednesday 8 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
